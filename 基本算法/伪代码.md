# 插入排序

``` c
InsertionSort(A[0..n-1])
//用插入排序对给定数组排序
//输入：n个可排序元素构成的一个数组A[0..n-1]
//输出：非降序排列的数组A[-..n-1]
    for i <- 1 to n-1 do
        v <- A[i]
        j <- i-1
        while j >= 0 and A[j] > v do
            A[j+1] <- A[j]
            j <- j-1
        A[j+1] <- v
```

# 折半查找

```java
BinarySearch(A[0..n-1],k)
 //实现非递归的折半查找
 //输入：一个升序数组元素A[0..n-1]和一个查找键k
 //输出：一个数组元素的下标，该元素等于k，若没有这样一个元素，则返回-1
    l <- 0; r<-n-1
    while l <= r do
        m <- (l+r)2   //向下取整
        if A[m]=k     return m
        else if A[m]>k   r <- m-1
        else l <- m+1
   return -1
```



# 选择问题

```c++
LomutoPartition(A[l..r])
//采用lomuto算法，用第一个元素作为中轴对子数组进行划分
//输入：数组A[0..n-1]的一个子数组A[l..r]，它由左右两边的索引l和r定义
//输出：A[l..r]的划分和中轴的新位置
	p <- A[l]
    s <- l
    for i <- l+1 to r do
    	if(A[i] < p)
        	s <- s+1
        	swap(A[i],A[s])
    swap(A[s],A[l])
    return s
```

# 合并排序

```C
MergeSort(A[0..n-1])
//递归调用mergesort来对数组进行排序
//输入：一个可排序的数组
//输出：非降序的数组
if(n>1)
	copy A[0..n/2」-1] to B[0..n/2」-1]   //向下取整
	copy A[n/2..n-1] to C[0..「n/2-1]
	MergeSort(B[0..n/2」-1])
	MergeSort(C[0..「n/2-1])
	Merge(B,C,A)
	
	
Merge(B[0..p-1], C[0..q-1],A[0..q+p-1])
//将两个有序数组合并为一个有序数组
//输入：两个有序素组B和C
//输出：有序数组
	i <- 0, j <- 0, k <- 0
	while i < p and j < q do
    	if(B[i] > C[j])  
    		A[k] <- C[j]; j <- j+1
    	else	A[k] <- B[i]; i <- i+1
    	k <- k+1
    if i = p
        copy C[j..q-1] to A[k..q+p-1]
    else
    	cope B[i..p-1] to A[k..q+p-1]
```



# 快速排序

```
Quicksort(A[l..r])
 //用快速排序对子数组进行排序
 //输入：数组A中的子数组
 //输出：非降序排列的子数组
 if l <r
 	s <- Partition(A[l..r])
    QuickSort(A[l..s-1])
    QuickSort(a[s+1..r])
    
  Partition(A[l..r])
  //以第一个元素为中轴，对子数组进行划分
  //输入：数组A中的子数组
  //输出：子数组的一个划分，分裂点位置作为返回值
 	i <- l+1; j <-r
 	p <- A[l]
 	repeat
 		repeat i <- i+1 until A[i] >= p
 		repeat j <- j+1 until A[j] =< p
 		swap(A[i],A[j])
 	until i >= j
 	swap(A[i],A[j])
 	swap(A[j],A[l])
 	return j
```



# 霍纳法则

```c
Horner(P[0..n],x)
//用霍纳法则求一个给定点的值
//输入:一个n次多项式的系数数组P
//输出：多项式在x点的值
	p <- P[n]
	for i <- n-1 to 0 do
		p <- x * p + P[i]
	return p
```



# Warshwall算法

```c
Warshall(A[0..n][0..n])
//实现计算传递闭包的Warshall算法
//输入：包括n个顶点有向图的邻接矩阵
//输出：该有向图的传递闭包
  R(0) <- A
  for k <- 0 to n do
  	for i <- 0 to n do
  		for j <- 0 to n do
  			R(k)[i][j] <- R(k-1)[i][j] or R(k-1)[i][k] and R(k-1)[k][j]
```







